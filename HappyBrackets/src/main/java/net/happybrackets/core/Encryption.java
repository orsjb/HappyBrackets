/*
 * Copyright 2017 Ollie Bown
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.happybrackets.core;

import com.sun.crypto.provider.AESKeyGenerator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.spec.KeySpec;

/**
 * Utility methods to encrypt and decrypt data.
 *
 * Based on http://stackoverflow.com/a/992413
 */
public class Encryption {
    final static Logger logger = LoggerFactory.getLogger(Encryption.class);

    private static String algorithm = "AES/CBC/PKCS5Padding";
    private static int ivLength = 16; //128 bits, same as block size for AES.
    private static int keyLength = 128;
    private static byte[] salt = "ke8#f$3jDl\\{weK63gH".getBytes();


    /**
     * @return The length in bytes of the initialisation vector generated by {@link #encrypt(String, byte[], int, int)}.
     */
    public static int getIVLength() {
        return ivLength;
    }


    private static SecretKey makeKey(String keyString) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec spec = new PBEKeySpec(keyString.toCharArray(), salt, 65536, keyLength);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES");
        return secret;
    }


    /**
     * Encrypt the given data.
     * @param key A user-supplied password/key.
     * @param input The data to encrypt.
     * @param offset The offset into the data to encrypt.
     * @param length The length of the data to encrypt, from offset.
     * @return The initialisation vector (index 0) and the encrypted data (index 1).
     */
    public static byte[][] encrypt(String key, byte[] input, int offset, int length) throws Exception {
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.ENCRYPT_MODE, makeKey(key));
        AlgorithmParameters params = cipher.getParameters();
        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encrypted = cipher.doFinal(input, offset, length);
        return new byte[][] {iv, encrypted};
    }


    /**
     * Decrypt the given data.
     * @param key A user-supplied password/key.
     * @param input The data to decrypt, prefixed with the initialisation vector (IV).
     * @param offset The offset into the data to decrypt (starting at IV).
     * @param length The length of the data to encrypt, from offset (NOT including length of IV).
     * @return The decrypted data.
     */
    public static byte[] decrypt(String key, byte[] input, int offset, int length) throws Exception {
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, makeKey(key), new IvParameterSpec(input, offset, ivLength));
        return cipher.doFinal(input, offset+ivLength, length);
    }
}
